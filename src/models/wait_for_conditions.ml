(*
 * This file has been generated by the OCamlClientCodegen generator for openapi-generator.
 *
 * Generated by: https://openapi-generator.tech
 *
 * Schema Wait_for_conditions.t : Conditions to apply to emails that you are waiting for
 *)

type t = {
    (* ID of inbox to search within and apply conditions to. Essentially filtering the emails found to give a count. *)
    inbox_id: string;
    (* Number of results that should match conditions. Either exactly or at least this amount based on the `countType`. If count condition is not met and the timeout has not been reached the `waitFor` method will retry the operation. *)
    count: int32 option [@default None];
    (* Max time in milliseconds to wait between retries if a `timeout` is specified. *)
    delay_timeout: int64 option [@default None];
    (* Max time in milliseconds to retry the `waitFor` operation until conditions are met. *)
    timeout: int64;
    (* Apply conditions only to **unread** emails. All emails begin with `read=false`. An email is marked `read=true` when an `EmailDto` representation of it has been returned to the user at least once. For example you have called `getEmail` or `waitForLatestEmail` etc., or you have viewed the email in the dashboard. *)
    unread_only: bool option [@default None];
    (* How result size should be compared with the expected size. Exactly or at-least matching result? *)
    count_type: Enums.counttype option [@default None];
    (* Conditions that should be matched for an email to qualify for results. Each condition will be applied in order to each email within an inbox to filter a result list of matching emails you are waiting for. *)
    matches: Match_option.t list;
    (* Direction to sort matching emails by created time *)
    sort_direction: Enums.sortdirection option [@default None];
    (* ISO Date Time earliest time of email to consider. Filter for matching emails that were received after this date *)
    since: string option [@default None];
    (* ISO Date Time latest time of email to consider. Filter for matching emails that were received before this date *)
    before: string option [@default None];
} [@@deriving yojson { strict = false }, show ];;

(** Conditions to apply to emails that you are waiting for *)
let create (inbox_id : string) (timeout : int64) : t = {
    inbox_id = inbox_id;
    count = None;
    delay_timeout = None;
    timeout = timeout;
    unread_only = None;
    count_type = None;
    matches = [];
    sort_direction = None;
    since = None;
    before = None;
}

